# ！！！！！！！！

打算开新坑了，目前这个项目的架构无法更好地实现我需要的一些功能。。。







# 项目简介

**Spell**是一个**Brainfuck-like**的简易编程语言，以图灵机模型为基础提供了多个指令，除了拥有Brainfuck所提供的操作外，还添加了数个方便的运算指令以及一套寄存器。由于以其编写的程序晦涩难懂，因此得名Spell，即**咒语**:star_and_crescent:。



# 模型

## 内存与寄存器

Spell的主要组成部分是一个无限长度的字节数组模拟的内存以及一个寄存器组，用户可通过指令`<`或`>`减小或增加指针值实现向左右两端移动指针以访问不同内存位置的字节单元，指针的最小值为0，由寄存器`qbx`记录，向左移动指针时不可小于该值。

在初始状态下，程序以内存模式运行，用户的运算、输入输出、数据交换操作等都会以当前内存单元为操作数，当用户使用`c`、`0`等命令选择寄存器后会进入寄存器模式，上述操作又会以对应寄存器为操作数。从寄存器模式改回内存模式可使用指令`@`，或者`><`，后者的原理是先将内存指针右移，然后再左移，达到内存单元位置不变而切换回内存模式的目的(移动内存指针会自动改回内存模式)。



## 寄存器组

Spell添加了一组寄存器以便更好地控制程序的运行，同时也向用户提供了多种方便的功能。所有的寄存器均为64位，这些寄存器大致分为特殊寄存器和通用寄存器，前者具有特殊意义，仅开放了一部分供用户访问，后者则全部可由用户自由使用，我们将其列举如下：

* 特殊寄存器

| 寄存器 | 作用                                             | 指令 | 备注     |
| ------ | ------------------------------------------------ | ---- | -------- |
| qbx    | 基址寄存器，保存了内存的最小地址                 |      | 不可访问 |
| qcx    | 条件/计数寄存器，控制循环的执行                  | c    | 可访问   |
| qdx    | 设备寄存器，当对设备执行IO操作时保存端口号       | d    | 可访问   |
| qfx    | 标志寄存器，保存程序运行时的各项标志             |      | 不可访问 |
| qix    | 指令寄存器，保存下一条执行的指令地址             |      | 不可访问 |
| qmx    | 模式寄存器，指定当前的访问模式(内存或某个寄存器) |      | 不可访问 |
| qox    | 偏移量寄存器，设置bit位等操作时由其提供偏移量    | o    | 可访问   |
| qpx    | 指针寄存器，指向当前操作的内存单元               | p    | 可访问   |
| qrx    | 结果寄存器，保存某些运算结果                     | r    | 可访问   |
| qtx    | 临时寄存器，参与某些运算和数据交换               | t    | 可访问   |

* 通用寄存器

| 寄存器 | 指令 |
| ------ | ---- |
| qc0    | 0    |
| qc1    | 1    |
| qc2    | 2    |
| qc3    | 3    |
| qc4    | 4    |
| qc5    | 5    |
| qc6    | 6    |
| qc7    | 7    |
| qc8    | 8    |
| qc9    | 9    |



## 设备





# 指令

为了方便描述，我们将内存单元和寄存器都统称为操作数。

## 基础指令

### 内存

| 指令 | 作用                              |
| ---- | --------------------------------- |
| <    | 内存指针左移一个单元，同步修改qpx |
| >    | 内存指针右移一个单元，同步修改qpx |



### 运算

| 指令 | 作用                                                         |
| ---- | ------------------------------------------------------------ |
| +    | 将操作数的值+1                                               |
| -    | 将操作数的值-1                                               |
| !    | 反转操作数，如果操作数为非0值，则反转为0，否则反转为1        |
| ^    | 根据qox的值设置操作数的对应位置的bit为1，例如qox为7，则将操作数的第8位bit置1 |
| ~    | 根据qox的值设置操作数的对应位置的bit为0                      |
| (    | 将操作数左移1位                                              |
| )    | 将操作数右移1位                                              |
| ?    | 将qtx的值与操作数相减，结果保存于qrx                         |



### 循环

| 指令 | 作用                              |
| ---- | --------------------------------- |
| [    | 当qcx为0时，前跳到另一侧的]之后   |
| ]    | 当qcx不为0时，回跳到另一侧的[之后 |



### 输入输出

| 指令 | 作用                                                     |
| ---- | -------------------------------------------------------- |
| .    | 将操作数对应的ASCII字符输出到终端，例如操作数为65时输出A |
| ,    | 从终端读入一个ASCII字符到操作数                          |
| :    | 将qtx的一个字节输出到qdx指定的端口号的设备中             |
| ;    | 从qdx指定的端口号的设备中读入一个字节到qtx中             |



### 数据交换

| 指令 | 作用                |
| ---- | ------------------- |
| #    | 将操作数保存到qtx   |
| =    | 将qtx值保存到操作数 |



### 停机

| 指令 | 作用         |
| ---- | ------------ |
| _    | 终止程序运行 |



## 选择指令

| 指令 | 作用                       |
| ---- | -------------------------- |
| @    | 选择内存，等价于使用指令>< |
| $    | 选择设备                   |
| c    | 选择qcx                    |
| o    | 选择qox                    |
| p    | 选择qpx                    |
| r    | 选择qrx                    |
| t    | 选择qtx                    |
| 0    | 选择qc0                    |
| 1    | 选择qc1                    |
| 2    | 选择qc2                    |
| 3    | 选择qc3                    |
| 4    | 选择qc4                    |
| 5    | 选择qc5                    |
| 6    | 选择qc6                    |
| 7    | 选择qc7                    |
| 8    | 选择qc8                    |
| 9    | 选择qc9                    |



# 构建

在Spell同级目录新建build目录，进入build目录，然后在该目录打开终端，使用CMake生成Makefile：

```cmake
cmake -G "Unix Makefiles" ../Spell
```

完成后，使用Make生成可执行文件：

```
make
```

待编译完毕后，进入bin目录下，找到spell.exe，假设我们的代码文件为*echo.sp*，则执行如下命令运行：

```
spell.exe echo.spe
```



# 应用

## 一个回显程序的实现

新建文件*echo.sp*，输入如下代码：

```
0+((((((+c+[@&#0?c#1=r#c=![_]@*1#c=]
```

这段代码实现了一个简单的回显程序，它会从终端中按字符读入用户输入并回显到终端，当用户输入大写字母A时终止。这段程序用到了大部分指令，让我们拆解如下：

**初始化A的ASCII码值到qc0寄存器(`0+((((((+`)**

`0`：选择寄存器qc0 

`+`：将寄存器值加1(寄存器值默认为0)

`((((((`：将qc0左移6位，此时qc0的值为64

`+`：将qc0加1，最终qc0的值为65，即A的ASCII码值

**设置qcx(`c+`)**

`c`：选择qcx

`+`：将qcx值加1，以便可以通过`[`的条件检查以进入循环内部

**进入循环(`[`)**

`[`：检查qcx的值，发现其值不为0，因此不执行跳转，程序继续向后执行

**从终端读取字符并与A计算(`@&#0?`)**

`@`：将访问模式修改回内存(因为前面使用c选择了qcx)

`&`：从终端读入一个字符并保存到当前内存单元

`#`：将内存单元的该字符转移到qtx

`0`：选择qc0

`?`：将qtx减去qc0，结果保存于qrx，这一步是为了在之后验证读入的字符与qc0中的字符A是否相同

**备份qcx(`c#1=`)**

`c`：选择qcx

`#`： 将qcx的值保存到qtx

`1`：选择qc1

`=`：将qtx的值保存到qc1

**设置比较结果(`r#c=!`)**

`r`：选择qrx

`#`：将qrx的值保存到qtx

`c`：选择qcx

`=`：将qtx的值保存到qcx

`!`：反转qcx，如果两个字符相同，那么qcx反转后为1，否则为0

**是否停机(`[_]`)**

`[`：检查qcx是否不为0，如果不为0则进入循环，此时遇到指令`_`从而让程序停机

`_`：程序停机

`]`：仅为了语法完整，实际上进入循环后遇到`_`程序就已结束，不会执行到此处

**打印字符(`@*`)**

`@`：切换为内存模式

`*`：打印当前内存单元的ASCII字符

**还原qcx(`1#c=`)**

`1`：选择qc1

`#`：将qc1的值保存到了qtx

`c`：选择qcx

`=`：将qtx的值保存到qcx，至此qc1备份的值还原到了qcx

**继续循环(`]`)**

`]`：检查qcx的值，发现其不为0，因此回跳到到`]`



# 附录



